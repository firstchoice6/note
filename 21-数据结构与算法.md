# 常见的数据结构

| 数据结构 | 优点                                                         | 缺点                                                         |
| -------- | ------------------------------------------------------------ | :----------------------------------------------------------- |
| 数组     | 根据下标值访问效率高<br />根据元素来查找对应的位置：对数组进行排序，再进行二分查找. | 需要先对数组进行排序，生成有序数组，才能提高查找效率。<br/>另外数组在插入和删除数据时，需要有大量的位移操作（插入到首位或者中间位置的时候），效率很低 |
| 链表     | 插入和删除操作效率都很高。<br />灵活的内存动态管理           | 查找效率很低，需要从头开始依次访问链表中的每个数据项，直到找到.<br/>而且即使插入和删除操作效率很高，但是如果要插入和删除中间位置的数据，还是需要重头先找到对应的数据. |
| 哈希表   | 插入/查询/删除效率都是非常高的                               | 空间利用率不高，底层使用的是数组，并且某些单元没有被利用<br/>元素无序，不能按照固定的顺序来遍历哈希表中的元素.<br/>不能快速的找出哈希表中的最大值或者最小值这些特殊的值. |
| 树       | 综合了上面的数据结构的优点，也弥补了上面数据结构的缺点.<br/>模拟某些场景使用树结构会更加方便.<br />因为树结构的非线性，可以表示一对多的关系比如文件的目录结构. |                                                              |



## 数组结构（Array）

## 栈结构（Stack）

栈是一种受限的线性表，后进先出（LIFO）

- 其限制是仅允许在**栈的一端**进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。

- LIFO(last in first out)表示就是后进入的元素，第一个弹出栈空间。

- 向一个栈插入新元素又称作**进栈、入栈或压栈**，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；

- 从一个栈删除元素又称作**出栈或退栈**，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。

### 栈的操作
- push(element):添加一个新元素到栈顶位置.

- pop()：移除栈顶的元素，同时返回被移除的元素。

- peek():返回栈顶的元素，不对栈做任何修改（这个方法不会移除栈顶的元素，仅仅返回它）。

- isEmpty()：如果栈里没有任何元素就返回true，否则返回false。

- size()：返回栈里的元素个数。这个方法和数组的length属性很类似。

- toString()：将栈结构的内容以字符形式返回。

### 封装栈

```js
1. 基于数组的栈
  function Stack() {
    // 栈中的属性
    this.items = [];
  
    // 栈相关的方法
    // 压栈操作
    Stack.prototype.push = function (element) {
        this.items.push(element);
    }
  
    // 出栈操作
    Stack.prototype.pop = function () {
        return this.items.pop();
    }
  
    // peek操作
    Stack.prototype.peek = function () {
        return this.items[this.items.length - 1];
    }
  
    // 判断栈中的元素是否为空
    Stack.prototype.isEmpty = function () {
        return this.items.length == 0;
    }
  
    // 获取栈中元素的个数
    Stack.prototype.size = function () {
        return this.items.length;
    }
    Stack.prototype.toString = function () {
        var resultString = '';
        for (var i = 0; i < this.items.length; i++) {
            resultString += this.items[i] + ' ';
        }
        return resultString;
    }
  }
--------------------------------------------------------------------------------------
应用：除k取余10进制转k进制 其实现过程很像栈的进栈出栈方法
function dec2k(decNum, k) {
    var stack = new Stack()；
    while (decNum > 0) {
           stack.push(decNum % k);
        	decNum = Math.floor(decNum/k);
           }
    var answer = '';
    while(!stack.isEmpty) {
        answer += stack.pop();
    }
    return +answer;
}
  2. 基于链表的栈
```

### 练习题

```
有六个元素6 5 4 3 2 1的顺序进栈，间问下列哪一个不是合法的出栈序列?（C）
A.543612	B.453216	C.346521	D.234156
// 不是一次性进栈 
A答案：65进栈，5出栈，4进栈出栈，3进栈出栈，6出栈，21进栈，1出栈，2出栈
B答案：654进栈，4出栈，5出栈；3进栈出栈，2进栈出栈，1进栈出栈，6出栈
D答案：65432进栈，2出栈，3出栈，4出栈，1进栈出栈，5出栈，6出栈
```


## 队列（Queue）

队列是一种受限的线性表，先进先出（FIFO）

- 其限制是仅允许在**队列的一端**进行插入运算，这一端被称为**后端**。另一端进行删除运算，称为**前端**。

### 队列的操作

- enqueue(element):向队列尾部添加一个（或多个）新的项。

- dequeue):移除队列的第一（即排在队列最前面的）项，并返回被移除的元素。

- front():返回队列中第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动

-  isEmpty():如果队列中不包含任何元素，返回true，否则返回false。

- size()：返回队列包含的元素个数，与数组的length属性类似。

- toString()：将队列中的内容，转成字符串形式

### 封装队列

```js
1.数组实现
function Queue() {
    this.items = [];
    
    Queue.prototype.enqueue = function (element) {
        this.items.push(element);
    }
    Queue.prototype.dequeue = function () {
        return this.items.shift();
    }
    Queue.prototype.front = function () {
        return this.items[0];
    }
    Queue.prototype.isEmpty = function () {
        return this.items.length == 0;
    }
    Queue.prototype.size = function () {
        return this.items.length;
    }
    Queue.prototype.toString = function () {
        var resultString = '';
        for(var i = 0; i < this.items.length; i++){
             resultString += this.items[i] + ' ';
        }    
        return resultString;
    }
}
-----------------------------------------------------------------------------
应用：击鼓传花/*规则
几个朋友一起玩一个游戏，围成一圈，轮流开始数数，数到某个数字的人自动淘汰.
最后剩下的这个人会获得胜利，请问最后剩下的是原来在哪一个位置上的人？*/
function passGame(nameList, number) {
     // 利用队列 每一轮，从前端开始 没有淘汰的人自动添加到后端，淘汰的人删除 size = 1的时候 游戏结束
    var queue = new Queue(); 
    // 创建队列
   	for (var i = 0; i < nameList.length; i++) {
            queue.enqueue(nameList[i]);
    }
    //将nameList中的人放在队列中
    while (queue.size() > 1) {
            for (var i = 0; i < num; i++) {
                queue.enqueue(queue.dequeue());
            }
            // 将前num-1中的人, 都从队列的前端取出放在队列的后端
            queue.dequeue();
        // 将第num个人, 从队列中移除
     } 
    alert("最终留下来的人:" + queue.dequeue());
    return nameList.indexOf(queue.dequeue());
}
2. 链表实现
```

### 优先级队列

> 优先级队列在插入一个元素的时候会考虑该元素的优先级，和其他数据优先级比较。比较完成后，可以得出这个元素在队列中的正确位置

```js
function PriorityQueue() {
    // 内部类
    function QueueElement(element, priority) {
        this.element = element;
        this.priority = priority;
    }
    this.items = [];
    
    PriorityQueue.prototype.enqueue = function(element, priority) {
        var queueElement = new QueueElement(element, priority);
        if (this.isEmpty()) {
            // 判断队列是否为空
                this.items.push(queueElement);
            } else {
                var added = false;
                for (var i = 0; i < this.items.length; i++) {
                    // 注意: 我们这里是数字越小, 优先级越高
                    if (queueElement.priority < this.items[i].priority) {
                        this.items.splice(i, 0, queueElement);
                        // i位置 修改0 插入queueElement
                        added = true;
                        break;
                    }
                }
                // 遍历完所有的元素, 优先级都大于新插入的元素时, 就插入到最后
                if (!added) {
                    this.items.push(queueElement);
                }
            }
   	 }
   		 // 删除元素的方法
        PriorityQueue.prototype.dequeue = function () {
            return this.items.shift();
        }

        // 获取前端的元素
        PriorityQueue.prototype.front = function () {
            return this.items[0];
        }

        // 查看元素是否为空
        PriorityQueue.prototype.isEmpty = function () {
            return this.items.length == 0;
        }

        // 获取元素的个数
        PriorityQueue.prototype.size = function () {
            return this.items.length;
        }
    	PriorityQueue.prototype.toString = function () {
        	var resultString = '';
       		for (var i = 0; i < this.items.length; i++) {
            	resultString += this.items[i].element + '-' + this.items[i].priority + ' ';
      	  	}
       		 return resultString;
    	}
}
```

## 链表

### 链表的操作

append(element)：向列表尾部添加一个新的项

insert(position,element):向列表的特定位置插入一个新的项。

get(position):获取对应位置的元素

indexOf(element):返回元素在列表中的索引。如果列表中没有该元素则返回-1。

update(position, element):修改某个位置的元素

removeAt(position)：从列表的特定位置移除一项。

remove(element):从列表中移除一项。

isEmpty():如果链表中不包含任何元素，返回true，如果链表长度大于0则返回false。

size()：返回链表包含的元素个数。与数组的length属性类似。

toString()：由于列表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值。

### 链表的封装

```js
function LinkedList() {
	//内部类
	function Node(data) {
		this.data = data;
		this.next = null;
	}
	// 属性
	this.head = null;
	this.length = 0;

	//append方法
	LinkedList.prototype.append = function (data) {
		// 1.创建新节点
		var newNode = new Node(data);
		if(this.length) {	
			this.head = newNode;
		} else {
			// 不是第一个节点
			var current = this.head;
			while (current.next) {
				current = current.next;
			}
			current.next = newNode;
		}
		this.length += 1;
	} 
    
    //toString方法
	LinkedList.prototype.toString = function () {
		var current = this.head;
		var listString = '';
		while (current) {
			listString += current.data + ' ';
			current = current.next;
		}
		return listString;
	}
    
    //insert方法
	LinkedList.prototype.insert = function (position, data) {
		//对position进行越界判断
		if(position < 0 || position > this.length) {
			return false;
		}
		var newNode = new Node(data);
		
		if (position == 0) {
			// position = 0
			newNode.next = this.head;
			this.head = newNode;
		} else {
			var index = 0;
			var current = this.head;
			var previous = null;
			while(index++ < position) {
				previous = current;
				current = current.next;
			}
			newNode.next = current;
			previous.next = newNode;
		}
		this.length++;
		return true;
	}
    
	// get方法
	LinkedList.prototype.get = function (position) {
		if(position < 0 || position >= this.length) {
			return null;
		}
		var current = this.head;
		var index = 0;
		while (index++ < position) {
			current = current.next;
		}
		return current.data;
	}

	//indexOf方法
	LinkedList.prototype.indexOf = function (data) {
		var current = this.head;
		var index = 0;
		while (current) {
			if (current.data == data) {
				return index;
			}
			current = current.next;
			index++;
		}
		return -1;
	}
    
 	// update
	LinkedList.prototype.get = function (position, newDate) {
		if(position < 0 || position >= this.length) {
			return null;
		}
		var current = this.head;
		var index = 0;
		while (index++ < position) {
			current = current.next;
		}
		current.data = newData;
		return true;
	}   
	// removeAt方法
	LinkedList.prototype.removeAt = function(position) {
		if(position < 0 || position >= this.length) {
			return false;
		}
		var current = this.head;
		if (position == 0) {
			this.head = this.head.next;
		} else {
			var index = 0;
			
			var previous = null;
			while (index++ < position) {
				previous = current;
				current = current.next;
			}
			previous.next = current.next;
		}
		this.length--;
		return current.data;		
	}

	// remove方法
	LinkedList.prototype.remove = function (data) {
		var position = this.indexOf(data);
		return this.removeAt(position);
	}
    
	//size
	LinkedList.prototype.size = function () {
		return this.length;
	}
    
	//isEmpty
	LinkedList.prototype.isEmpty = function () {
		return this.length == 0;
	}
}	


```

### 双向链表

```js
function DoublyLinkedList() {
    // 创建节点构造函数
    function Node(element) {
        this.element = element
        this.next = null
        this.prev = null // 新添加的
    }

    // 定义属性
    this.length = 0
    this.head = null
    this.tail = null // 新添加的

    // 定义相关操作方法
    // 在尾部追加数据
    DoublyLinkedList.prototype.append = function (element) {
        // 1.根据元素创建节点
        var newNode = new Node(element)

        // 2.判断列表是否为空列表
        if (this.head == null) {
            this.head = newNode
            this.tail = newNode
        } else {
            this.tail.next = newNode
            newNode.prev = this.tail
            this.tail = newNode
        }

        // 3.length+1
        this.length++
    }

    // 在任意位置插入数据
    DoublyLinkedList.prototype.insert = function (position, element) {
        // 1.判断越界的问题
        if (position < 0 || position > this.length) return false

        // 2.创建新的节点
        var newNode = new Node(element)

        // 3.判断插入的位置
        if (position === 0) { // 在第一个位置插入数据
            // 判断链表是否为空
            if (this.head == null) {
                this.head = newNode
                this.tail = newNode
            } else {
                this.head.prev = newNode
                newNode.next = this.head
                this.head = newNode
            }
        } else if (position === this.length) { // 插入到最后的情况
            // 思考: 这种情况是否需要判断链表为空的情况呢? 答案是不需要, 为什么?
            this.tail.next = newNode
            newNode.prev = this.tail
            this.tail = newNode
        } else { // 在中间位置插入数据
            // 定义属性
            var index = 0
            var current = this.head
            var previous = null

            // 查找正确的位置
            while (index++ < position) {
                previous = current
                current = current.next
            }

            // 交换节点的指向顺序
            newNode.next = current
            newNode.prev = previous
            current.prev = newNode
            previous.next = newNode
        }

        // 4.length+1
        this.length++

        return true
    }

    // 根据位置删除对应的元素
    DoublyLinkedList.prototype.removeAt = function (position) {
        // 1.判断越界的问题
        if (position < 0 || position >= this.length) return null

        // 2.判断移除的位置
        var current = this.head
        if (position === 0) {
            if (this.length == 1) {
                this.head = null
                this.tail = null
            } else {
                this.head = this.head.next
                this.head.prev = null
            }
        } else if (position === this.length -1) {
            current = this.tail
            this.tail = this.tail.prev
            this.tail.next = null
        } else {
            var index = 0
            var previous = null

            while (index++ < position) {
                previous = current
                current = current.next
            }

            previous.next = current.next
            current.next.prev = previous
        }

        // 3.length-1
        this.length--

        return current.element
    }

    // 根据元素获取在链表中的位置
    DoublyLinkedList.prototype.indexOf = function (element) {
        // 1.定义变量保存信息
        var current = this.head
        var index = 0

        // 2.查找正确的信息
        while (current) {
            if (current.element === element) {
                return index
            }
            index++
            current = current.next
        }

        // 3.来到这个位置, 说明没有找到, 则返回-1
        return -1
    }

    // 根据元素删除
    DoublyLinkedList.prototype.remove = function (element) {
        var index = this.indexOf(element)
        return this.removeAt(index)
    }

    // 判断是否为空
    DoublyLinkedList.prototype.isEmpty = function () {
        return this.length === 0
    }

    // 获取链表长度
    DoublyLinkedList.prototype.size = function () {
        return this.length
    }

    // 获取第一个元素
    DoublyLinkedList.prototype.getHead = function () {
        return this.head.element
    }

    // 获取最后一个元素
    DoublyLinkedList.prototype.getTail = function () {
        return this.tail.element
    }

    // 遍历方法的实现
    // 正向遍历的方法
    DoublyLinkedList.prototype.forwardString = function () {
        var current = this.head
        var forwardStr = ""

        while (current) {
            forwardStr += "," + current.element
            current = current.next
        }

        return forwardStr.slice(1)
    }

    // 反向遍历的方法
    DoublyLinkedList.prototype.reverseString = function () {
        var current = this.tail
        var reverseStr = ""

        while (current) {
            reverseStr += "," + current.element
            current = current.prev
        }

        return reverseStr.slice(1)
    }

    // 实现toString方法
    DoublyLinkedList.prototype.toString = function () {
        return this.forwardString()
    }
}
```



## 集合结构（Set）

> 两个特点：无序，元素不能重复

### 集合的操作

- add(value)：向集合添加一个新的项。
- remove(value)：从集合移除一个值。
- has(value)：如果值在集合中，返回true，否则返回false。
- clear()：移除集合中的所有项。
- size()：返回集合所包含元素的数量。与数组的length属性类似。
- values():返回一个包含集合中所有值的数组。
- 还有一些集合其他相关的操作，暂时用不太多，这里暂不封装.

### 封装集合

```js
// 封装集合的构造函数
function Set() {
    // 使用一个对象来保存集合的元素
    this.items = {};

    // 集合的操作方法
    // 判断集合中是否有某个元素
    Set.prototype.has = function (value) {
        return this.items.hasOwnProperty(value);
    }

    // 向集合中添加元素
    Set.prototype.add = function (value) {
        // 1.判断集合中是否已经包含了该元素
        if (this.has(value)) return false;

        // 2.将元素添加到集合中
        this.items[value] = value;
        return true;
    }

    // 从集合中删除某个元素
    Set.prototype.remove = function (value) {
        // 1.判断集合中是否包含该元素
        if (!this.has(value)) return false;

        // 2.包含该元素, 那么将元素删除
        delete this.items[value];
        return true;
    }

    // 清空集合中所有的元素
    Set.prototype.clear = function () {
        this.items = {};
    }

    // 获取集合的大小
    Set.prototype.size = function () {
        return Object.keys(this.items).length;

        /*
        考虑兼容性问题, 使用下面的代码
        var count = 0
        for (var value in this.items) {
            if (this.items.hasOwnProperty(value)) {
                count++
            }
        }
        return count
        */
    }

    // 获取集合中所有的值
    Set.prototype.values = function () {
        return Object.keys(this.items)

        /*
        考虑兼容性问题, 使用下面的代码
        var keys = []
        for (var value in this.items) {
            keys.push(value)
        }
        return keys
        */
    }
}
```

### 集合间的操作

```js
function Set() {
	/**上面重复代码略**/
    // 并集
	Set.prototype.union = function (otherSet) {
        // this 集合A
        // otherSet 集合B
        var unionSet = new Set();
        var values = this.values();
        for (var i = 0; i < values.length; i++) {
            unionSet.add(values[i]);
        }
        values = otherSet.values();
        for (var i = 0; i < values.length; i++) {
            unionSet.add(values[i]);
        }
        return unionSet;
    }
    
    // 交集
    Set.prototype.intersection = function (otherSet) {
        var intersectionSet = new Set();
        var values = this.values();
        for (var i = 0; i < values.length; i++) {
            var item = values[i];
            if (otherSet.has(item)) {
                intersectionSet.add(item);
            }
        }
        return intersectionSet;
    }
    
    // 差集
    Set.prototype.difference = function (otherSet) {
        var differenceSet = new Set();
        var values = this.values();
        for (var i = 0; i < values.length; i++) {
            var item = values[i];
            if (!otherSet.has(item)) {
                differenceSet.add(item);
            }
        }
        return differenceSet;
    }
    
    // 子集
  	Set.prototype.subset = function (otherSet) {
        var values = this.values();
        for (var i = 0; i < values.length; i++) {
            var item = values[i];
            if (otherSet.has(item)) {
                return false;
            }
        }
        return true;
    }
}  
```

## 字典

- 字典和映射的关系：

  有些编程语言中称这种映射关系为字典，因为它确实和生活中的字典比较相似.（比如Swift中Dictionary,Python中的dict)

  有些编程语言中称这种映射关系为Map，注意Map在这里不要翻译成地图，而是翻译成映射.（比如Java中就有HashMap&TreeMap等）

- 字典和数组：

  字典和数组对比的话，字典可以非常方便的通过key来搜索对应的value，key可以包含特殊含义，也更容易被人们记住.

- 字典和对象：

  很多编程语言（比如Java）中对字典和对象区分比较明显，对象通常是一种在编译期就确定下来的结构，不可以动态的添加或者删除属性，而字典通常会使用类似于哈希表的数据结构去实现一种可以动态的添加数据的结构.

  **但是在JavaScript中，似乎对象本身就是一种字典，所有在早期的JavaScript中，没有字典这种数据类型，因为你完全可以使用对象去代替.**

  ```js
      // 创建字典的构造函数
      function Dictionay() {
          // 字典属性
          this.items = {}
  
          // 字典操作方法
          // 在字典中添加键值对
          Dictionay.prototype.set = function (key, value) {
              this.items[key] = value
          }
  
          // 判断字典中是否有某个key
          Dictionay.prototype.has = function (key) {
              return this.items.hasOwnProperty(key)
          }
  
          // 从字典中移除元素
          Dictionay.prototype.remove = function (key) {
              // 1.判断字典中是否有这个key
              if (!this.has(key)) return false
  
              // 2.从字典中删除key
              delete this.items[key]
              return true
          }
  
          // 根据key去获取value
          Dictionay.prototype.get = function (key) {
              return this.has(key) ? this.items[key] : undefined
          }
  
          // 获取所有的keys
          Dictionay.prototype.keys = function () {
              return Object.keys(this.items)
          }
  
          // 获取所有的value
          Dictionay.prototype.values = function () {
              return Object.values(this.items)
          }
  
          // size方法
          Dictionay.prototype.size = function () {
              return this.keys().length
          }
  
          // clear方法
          Dictionay.prototype.clear = function () {
              this.items = {}
          }
      }
  ```

## 哈希表

> 哈希化：将大数字转化成数组范围内下标的过程，我们就称之为哈希化.

> 哈希函数：通常我们会将单词转成大数字，大数字在进行哈希化的代码实现放在一个函数中，这个函数我们成为哈希函数.

> 哈希表：最终将数据插入到的这个数组，对整个结构的封装，我们就称之为是一个哈希表

- 解决冲突的方法

  - 链地址法（拉链法）

    ```
    每个数组单元中存储的不再是单个数据，而是一个链条.
    ```

  - ~~开放地址法~~

    ```
    寻找空白的单元格来添加重复的数据
    1. 线性探测
    	步长为1的探测，存在聚集问题
    2. 二次探测
    	x+1^2 x+2^2 x+3^2，也会聚集，概率小一些，存在步长不一的聚集
    3. 再哈希法
    	第一次哈希化结果作为下标，第二次哈希化结果作为步长
    	stepSize = constant - (key % constant)
    	常量constant是质数，且小于数组容量
    ```

    

- 霍纳法则（快速计算）

  ```js
  提取公因式以简化步骤
  Pn(x)=anx^n+a(n-1)x^(n-1)+..+a1x+a0=(..（((anx +an-1)x+an-2)x+an-3)..)x+a1)x+a0
  ```

- 质数的使用（均匀分布）
  	· 哈希表的长度（再哈希法重要，链地址法不重要）
      · N次幂的底数

### 哈希函数

```js
function hashFunc(str, max) {
        // 1.初始化hashCode的值
    var hashCode = 0;
        // 2.霍纳算法, 来计算hashCode的数值
    for (var i = 0; i < str.length; i++) {
         hashCode = 37 * hashCode + str.charCodeAt(i);
        /*比如'abc' a - 97， b - 98, c - 99; 37是一个用得比较多的数字，并不唯一
        哈希码 = 97*37^2 + 98*37 + 99 = 136518 mod 7 = 4;
        霍纳法则下 
        哈希码 = (97*37 + 98)*37 + 99 
        i = 0; hashcode = 97
        i = 1; hashcode = 37*97 + 98
        i = 2; hashcode = (37*97 + 98)*37 + 99
        */
     }
         // 将大的数字hashcode压缩到数组范围之内
        // 3.取模运算
     hashCode = hashCode % max;
     return hashCode;
    }
}
```

### 哈希表（链地址法实现）

~~~js
function HashTable() {
    // 定义属性
    this.storage = []; // 数组
    this.count = 0; // 已存数据个数
    this.limit = 8; // 一共可以存放多少个数据
    // 哈希表的数据格式：[[[key,value],[k,v],[k,v]...],[[k,v],[k,v],[k,v]]...]
	
    // 定义相关方法
    // 判断是否是质数
    HashTable.prototype.isPrime = function (num) {
        var temp = parseInt(Math.sqrt(num))
        // 2.循环判断
        for (var i = 2; i <= temp; i++) {
            if (num % i == 0) {
                return false
            }
        }
        return true
    }

    // 获取质数
    HashTable.prototype.getPrime = function (num) {
        while (!isPrime(num)) {
            num++;
        }
        return num
    }

    // 哈希函数
    HashTable.prototype.hashFunc = function(str, max) {
        // 1.初始化hashCode的值
        var hashCode = 0
        // 2.霍纳算法, 来计算hashCode的数值
        for (var i = 0; i < str.length; i++) {
            hashCode = 37 * hashCode + str.charCodeAt(i)
        }
        // 3.取模运算
        hashCode = hashCode % max
        return hashCode
    }

    // 插入数据方法
    /*
    1.根据key获取索引值
	目的：将数据插入到对应的位置

	2.根据索引值取出bucket
	1）如果桶不存在，创建桶，并且放置在该索引的位置

	3.判断新增还是修改原来的值
	·如果已经有值了，那么就修改值
	·如果没有，执行后续的添加操作
	
	4.新增操作
	*/
    HashTable.prototype.put = function (key, value) {
        // 1.获取key对应的index
        var index = this.hashFunc(key, this.limit);

        // 2.取出数组(也可以使用链表)
        var bucket = this.storage[index];

        // 3.判断这个数组是否存在
        if (bucket === undefined) {
            // 3.1创建桶
            bucket = [];
            this.storage[index] = bucket;
        }

        // 4.判断是新增还是修改原来的值.
        var override = false;
        for (var i = 0; i < bucket.length; i++) {
            var tuple = bucket[i]; // 原组
            if (tuple[0] === key) {
                tuple[1] = value;
                override = true;
            }
        }

        // 5.如果是新增, 前一步没有覆盖
        if (!override) {
            bucket.push([key, value]);
            this.count++；

            if (this.count > this.limit * 0.75) {
                var primeNum = this.getPrime(this.limit * 2);
                this.resize(primeNum);
            }
        }
    }

    // 获取存放的数据
    HashTable.prototype.get = function (key) {
        // 1.获取key对应的index
        var index = this.hashFunc(key, this.limit);

        // 2.获取对应的bucket
        var bucket = this.storage[index];

        // 3.如果bucket为null, 那么说明这个位置没有数据
        if (bucket == null) {
            return null;
        }

        // 4.有bucket, 判断是否有对应的key
        for (var i = 0; i < bucket.length; i++) {
            var tuple = bucket[i];
            if (tuple[0] === key) {
                return tuple[1];
            }
        }

        // 5.没有找到, return null
        return null;
    }

    // 删除数据
    HashTable.prototype.remove = function (key) {
        // 1.获取key对应的index
        var index = this.hashFunc(key, this.limit)

        // 2.获取对应的bucket
        var bucket = this.storage[index]

        // 3.判断同是否为null, 为null则说明没有对应的数据
        if (bucket == null) {
            return null
        }

        // 4.遍历bucket, 寻找对应的数据
        for (var i = 0; i < bucket.length; i++) {
            var tuple = bucket[i]
            if (tuple[0] === key) {
                bucket.splice(i, 1)
                this.count--

                // 缩小数组的容量
                if (this.limit > 7 && this.count < this.limit * 0.25) {
                    var primeNum = this.getPrime(Math.floor(this.limit / 2))
                    this.resize(primeNum)
                }
            }
            return tuple[1]
        }

        // 5.来到该位置, 说明没有对应的数据, 那么返回null
        return null
    }

    // isEmpty方法
    HashTable.prototype.isEmpty = function () {
        return this.count == 0
    }

    // size方法
    HashTable.prototype.size = function () {
        return this.count
    }

    // 哈希表扩容/缩容
    HashTable.prototype.resize = function (newLimit) {
        // 1.保存旧的数组内容
        var oldStorage = this.storage;

        // 2.重置属性
        this.limit = newLimit;
        this.count = 0;
        this.storage = [];

        // 3.遍历旧数组中的所有数据项, 并且重新插入到哈希表中
        oldStorage.forEach(function (bucket) {
            // 1.bucket为null, 说明这里面没有数据
            if (bucket == null) {
                return
            }

            // 2.bucket中有数据, 那么将里面的数据重新哈希化插入
            for (var i = 0; i < bucket.length; i++) {
                var tuple = bucket[i]
                this.put(tuple[0], tuple[1])
            }
        }).bind(this)
    }
}
~~~

## 树结构（Tree）

### 树的术语

1. 节点的度（Degree）：节点的子树个数.

2. 树的度：树的所有节点中最大的度数。

3. 叶节点（Leaf)：度为0的节点。（也称为叶子节点）

4. 父节点（Parent)：有子树的节点是其子树的根节点的父节点

5. 子节点（Child)：若A节点是B节点的父节点，则称B节点是A节点的子节点；子节点也称孩子节点。

6. 兄弟节点（Sibling）：具有同一父节点的各节点彼此是兄弟节点。

7. 路径和路径长度：从节点n1到nk的路径为一个节点序列n1，n2，nk,ni是ni+1的父节点。路径所包含边的个数为路径的长度。

8. 节点的层次（Level）：规定根节点在1层，其它任一节点的层数是其父节点的层数加1。

9. 树的深度（Depth)：树中所有节点中的最大层次是这棵树的深度。

### 二叉树的遍历

- 先序遍历
- 后序遍历
- 中序遍历
- 层序遍历


### 二叉搜索树(BST, Binary Search Tree)

> 性质：
>
> ​	非空左子树的所有键值小于其根节点的键值。
>
> ​	非空右子树的所有键值大于其根节点的键值。
>
> ​	左、右子树本身也都是二叉搜索树。
>
> 特点：
>
> ​	相对较小的值总是保存在左节点上，相对较大的值总是保存在右节点上.

### 二叉树操作

insert(key):向树中插入一个新的键。

search(key)：在树中查找一个键，如果节点存在，则返回true；如果不存在，则返回false。

inOrderTraverse:通过中序遍历方式遍历所有节点。

preOrderTraverse:通过先序遍历方式遍历所有节点。

postOrderTraverse:通过后序遍历方式遍历所有节点。

min：返回树中最小的值/键。

max：返回树中最大的值/键。

remove(key):从树中移除某个键。

```js
function BinarySerachTree() {
    // 创建节点构造函数
    function Node(key) {
        this.key = key
        this.left = null
        this.right = null
    }

    // 保存根的属性
    this.root = null

    // 二叉搜索树相关的操作方法
    // 向树中插入数据
    BinarySerachTree.prototype.insert = function (key) {
        // 1.根据key创建对应的node
        var newNode = new Node(key)

        // 2.判断根节点是否有值
        if (this.root === null) {
            this.root = newNode
        } else {
            this.insertNode(this.root, newNode)
        }
    }

    BinarySerachTree.prototype.insertNode = function (node, newNode) {
        if (newNode.key < node.key) { // 1.准备向左子树插入数据
            if (node.left === null) { // 1.1.node的左子树上没有内容
                node.left = newNode
            } else { // 1.2.node的左子树上已经有了内容
                this.insertNode(node.left, newNode)
            }
        } else { // 2.准备向右子树插入数据
            if (node.right === null) { // 2.1.node的右子树上没有内容
                node.right = newNode
            } else { // 2.2.node的右子树上有内容
                this.insertNode(node.right, newNode)
            }
        }
    }

    // 获取最大值和最小值
    BinarySerachTree.prototype.min = function () {
        var node = this.root
        while (node.left !== null) {
            node = node.left
        }
        return node.key
    }

    BinarySerachTree.prototype.max = function () {
        var node = this.root
        while (node.right !== null) {
            node = node.right
        }
        return node.key
    }

    // 搜搜特定的值
    /*
    BinarySerachTree.prototype.search = function (key) {
        return this.searchNode(this.root, key)
    }

    BinarySerachTree.prototype.searchNode = function (node, key) {
        // 1.如果传入的node为null那么, 那么就退出递归
        if (node === null) {
            return false
        }

        // 2.判断node节点的值和传入的key大小
        if (node.key > key) { // 2.1.传入的key较小, 向左边继续查找
            return this.searchNode(node.left, key)
        } else if (node.key < key) { // 2.2.传入的key较大, 向右边继续查找
            return this.searchNode(node.right, key)
        } else { // 2.3.相同, 说明找到了key
            return true
        }
    }
    */
    BinarySerachTree.prototype.search = function (key) {
        var node = this.root
        while (node !== null) {
            if (node.key > key) {
                node = node.left
            } else if (node.key < key) {
                node = node.right
            } else {
                return true
            }
        }
        return false
    }

    // 删除节点
    BinarySerachTree.prototype.remove = function (key) {
        // 1.获取当前的node
        var node = this.root
        var parent = null

        // 2.循环遍历node
        while (node) {
            if (node.key > key) {
                parent = node
                node = node.left
            } else if (node.key < key) {
                parent = node
                node = node.right
            } else {
                if (node.left == null && node.right == null) {

                }
            }
        }
    }

    BinarySerachTree.prototype.removeNode = function (node, key) {
        // 1.如果传入的node为null, 直接退出递归.
        if (node === null) return null

        // 2.判断key和对应node.key的大小
        if (node.key > key) {
            node.left = this.removeNode(node.left, key)

        }
    }

    // 删除结点
    BinarySerachTree.prototype.remove = function (key) {
        // 1.定义临时保存的变量
        var current = this.root
        var parent = this.root
        var isLeftChild = true

        // 2.开始查找节点
        while (current.key !== key) {
            parent = current
            if (key < current.key) {
                isLeftChild = true
                current = current.left
            } else {
                isLeftChild = false
                current = current.right
            }

            // 如果发现current已经指向null, 那么说明没有找到要删除的数据
            if (current === null) return false
        }

        // 3.删除的结点是叶结点
        if (current.left === null && current.right === null) {
            if (current == this.root) {
                this.root == null
            } else if (isLeftChild) {
                parent.left = null
            } else {
                parent.right = null
            }
        }

        // 4.删除有一个子节点的节点
        else if (current.right === null) {
            if (current == this.root) {
                this.root = current.left
            } else if (isLeftChild) {
                parent.left = current.left
            } else {
                parent.right = current.left
            }
        } else if (current.left === null) {
            if (current == this.root) {
                this.root = current.right
            } else if (isLeftChild) {
                parent.left = current.right
            } else {
                parent.right = current.right
            }
        }

        // 5.删除有两个节点的节点
        else {
            // 1.获取后继节点
            var successor = this.getSuccessor(current)

            // 2.判断是否是根节点
            if (current == this.root) {
                this.root = successor
            } else if (isLeftChild) {
                parent.left = successor
            } else {
                parent.right = successor
            }

            // 3.将删除节点的左子树赋值给successor
            successor.left = current.left
        }

        return true
    }

    // 找后继的方法
    BinarySerachTree.prototype.getSuccessor = function (delNode) {
        // 1.使用变量保存临时的节点
        var successorParent = delNode
        var successor = delNode
        var current = delNode.right // 要从右子树开始找

        // 2.寻找节点
        while (current != null) {
            successorParent = successor
            successor = current
            current = current.left
        }

        // 3.如果是删除图中15的情况, 还需要如下代码
        if (successor != delNode.right) {
            successorParent.left = successorParent.right
            successor.right = delNode.right
        }
    }

    // 遍历方法
    // 先序遍历
    BinarySerachTree.prototype.preOrderTraversal = function (handler) {
        this.preOrderTranversalNode(this.root, handler)
    }

    BinarySerachTree.prototype.preOrderTranversalNode = function (node, handler) {
        if (node !== null) {
            handler(node.key)
            this.preOrderTranversalNode(node.left, handler)
            this.preOrderTranversalNode(node.right, handler)
        }
    }

    // 中序遍历
    BinarySerachTree.prototype.inOrderTraversal = function (handler) {
        this.inOrderTraversalNode(this.root, handler)
    }

    BinarySerachTree.prototype.inOrderTraversalNode = function (node, handler) {
        if (node !== null) {
            this.inOrderTraversalNode(node.left, handler)
            handler(node.key)
            this.inOrderTraversalNode(node.right, handler)
        }
    }

    // 后续遍历
    BinarySerachTree.prototype.postOrderTraversal = function (handler) {
        this.postOrderTraversalNode(this.root, handler)
    }

    BinarySerachTree.prototype.postOrderTraversalNode = function (node, handler) {
        if (node !== null) {
            this.postOrderTraversalNode(node.left, handler)
            this.postOrderTraversalNode(node.right, handler)
            handler(node.key)
        }
    }
}
```

## 红黑树

### 特点

除了符合二叉搜索树的基本规则外

1. 节点是红色或黑色。

2. 根节点是黑色。

3. 每个叶子节点都是黑色的空节点（NIL节点）。

4. 每个红色节点的两个子节点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色节点）

5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

> 前面的约束，确保了红黑树的关键特性：
>
> ​	从根到叶子的最长可能路径，不会超过最短可能路径的两倍长.
>
> ​	结果就是这个树基本是平衡的.
>
> ​	虽然没有做到绝对的平衡，但是可以保证在最坏的情况下，依然是高效的.
>
> 为什么可以做到最长路径不超过最短路径的两倍呢？
>
> ​	性质4决定了路径不能有两个相连的红色节点
>
> ​	最短的可能路径都是黑色节点。
>
> ​	最长的可能路径是红色和黑色交替
>
> ​	性质5所有路径都有相同数目的黑色节点.
>
> ​	这就表明了没有路径能多余任何其他路径的两倍长.

### 变色和旋转

变色：

​	为了重新符合红黑树的规则，尝试把红色节点变为黑色，或者把黑色节点变为红色。

首先，需要知道插入的新的节点通常都是红色节点。

​	因为在插入节点为红色的时候，有可能插入一次是不违反红黑树任何规则的

​	而插入黑色节点，必然会导致有一条路径上多了黑色节点，这是很难调整的！

​	红色节点可能导致出现红红相连的情况，但是这种情况可以通过颜色调换和旋转来调整

左旋转

​	逆时针旋转红黑树的两个节点

右旋转

​	顺时针旋转红黑树的两个节点

### 红黑树的插入操作

1. 新节点N位于树的根上，没有父节点

        直接变化红色为黑色

2. 新节点的父节点P是黑色

        直接插入，不需要任何变换

3. 新节点的父节点P是红色，叔节点U也是红色

        父红叔红祖黑 ===> 父黑叔黑祖红
    
4. 父红叔黑祖黑，且N是左孩子
   
        父黑祖红右旋转

5. 父红叔黑祖黑，且N是右孩子
       以P为根左旋转 将p作为新节点考虑
        	N黑祖红，以祖为根右旋转

## 图结构

> 图结构是一种与树结构有些相似的数据结构.
>
> 图论是数学的一个分支，并且，在数学的概念上，树是图的一种.
>
> 它以图为研究对象，研究顶点和边组成的图形的数学理论和方法.
>
> 主要研究的目的是事物之间的关系，**顶点代表事物，边代表两个事物间的关系**

### 图的遍历

- 广度优先(Breadth-First Search，简称BFS)
- 深度优先(Depth-First Search，简称DFS)

### 图的封装

```js
function Graph() {
    // 属性
    this.vertexes = [] // 存储顶点
    this.adjList = new Dictionay() // 存储边

    // 添加方法
    Graph.prototype.addVertex = function (v) {
        this.vertexes.push(v)
        this.adjList.set(v, [])
    }

    Graph.prototype.addEdge = function (v, w) {
        this.adjList.get(v).push(w)
        this.adjList.get(w).push(v)
    }

    Graph.prototype.toString = function () {
        var resultStr = ""
        for (var i = 0; i < this.vertexes.length; i++) {
            resultStr += this.vertexes[i] + "->"
            var adj = this.adjList.get(this.vertexes[i])
            for (var j = 0; j < adj.length; j++) {
                resultStr += adj[j] + " "
            }
            resultStr += "\n"
        }
        return resultStr
    }

    // 初始化颜色
    Graph.prototype.initializeColor = function () {
        var colors = []
        for (var i = 0; i < this.vertexes.length; i++) {
            colors[this.vertexes[i]] = "white"
        }
        return colors
    }

    // 广度优先算法
    Graph.prototype.bfs = function (v, handler) {
        // 1.初始化颜色
        var color = this.initializeColor()

        // 2.创建队列
        var queue = new Queue()

        // 3.将传入的顶点放入队列中
        queue.enqueue(v)

        // 4.从队列中依次取出和放入数据
        while (!queue.isEmpty()) {
            // 4.1.从队列中取出数据
            var qv = queue.dequeue()

            // 4.2.获取qv相邻的所有顶点
            var qAdj = this.adjList.get(qv)

            // 4.3.将qv的颜色设置成灰色
            color[qv] = "gray"

            // 4.4.将qAdj的所有顶点依次压入队列中
            for (var i = 0; i < qAdj.length; i++) {
                var a = qAdj[i]
                if (color[a] === "white") {
                    color[a] = "gray"
                    queue.enqueue(a)
                }
            }

            // 4.5.因为qv已经探测完毕, 将qv设置成黑色
            color[qv] = "black"

            // 4.6.处理qv
            if (handler) {
                handler(qv)
            }
        }
    }

    // 深度优先搜索
    Graph.prototype.dfs = function (handler) {
        // 1.初始化颜色
        var color = this.initializeColor()

        // 2.遍历所有的顶点, 开始访问
        for (var i = 0; i < this.vertexes.length; i++) {
            if (color[this.vertexes[i]] === "white") {
                this.dfsVisit(this.vertexes[i], color, handler)
            }
        }
    }

    // dfs的递归调用方法
    Graph.prototype.dfsVisit = function (u, color, handler) {
        // 1.将u的颜色设置为灰色
        color[u] = "gray"

        // 2.处理u顶点
        if (handler) {
            handler(u)
        }

        // 3.u的所有邻接顶点的访问
        var uAdj = this.adjList.get(u)
        for (var i = 0; i < uAdj.length; i++) {
            var w = uAdj[i]
            if (color[w] === "white") {
                this.dfsVisit(w, color, handler)
            }
        }

        // 4.将u设置为黑色
        color[u] = "black"
    }
}
```

# 排序算法

